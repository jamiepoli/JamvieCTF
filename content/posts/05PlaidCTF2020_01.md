---
title: "PlaidCTF 2020: Contrived Web Problem"
date: 2020-04-28T00:48:12-06:00
draft: true
---


This was a CTF I unfortunately didn't have the time for, as I was busy doing finals in April :(. My team let me know about this cool and unqiue problem, and I'm glad they did! 
<!--more-->


This was a journey in understanding internet protocols that deepened my knowledge of them to completely new levels, so I'm really grateful I got the chance to try this problem out - even though I tried it after the CTF ended :P



Let's Begin!
----

This problem really holds up to its name. The website is simple - you have the option to login or register as a new user. 

![CWP01](https://raw.githubusercontent.com/jamiepoli/JamvieCTF/master/content/images/CWP01.png)

Uniquely, we are given the source code for the problem. 

First things first then, since we have the source code, let's see if we can find any flag.txt files in it! 

![CWP03](https://raw.githubusercontent.com/jamiepoli/JamvieCTF/master/content/images/CWP03.png)

That was really easy to find...
It's in the services dockerfile, which is only used by api, email and server services. So, the vulnerability probably is within one of these services. 

I checked out api first - and I see that the only protocols that it allows are http, https and ftp. 

Looking at email next, which uses nodemailer. I'm not too familiar with it, so I check out its documentation: 

![CWP02](https://raw.githubusercontent.com/jamiepoli/JamvieCTF/master/content/images/CWP02.png)

This seems like a good loophole to exploit - we just need to specify the filepath and nodemailer will send an email with an attachment of whatever file we specified by the filepath. So, we will literally ask it to email us flag.txt! 

Now the hard part - how do we send a request to the server to send us the email with the flag as an attachment? 

I spent a long time trying to figure out how to send a rogue request to the rabbitmq server that will send us the email we want. I spent hours just browsing through the source code, not really paying attention... 

Until I came across this piece of code in the api index.ts file: 

```js
    app.get("/image", async (req, res) => {
        let { url } = req.query;
        if (typeof url !== "string") {
            return res.status(500).send("Bad body");
        }

        let parsed = new URL(url);

        let image: Buffer;
        if (parsed.protocol === "http:" || parsed.protocol === "https:") {
            const imageReq = await fetch(parsed.toString(), { method: "GET" });
            image = await (imageReq as any).buffer();
        } 
        
         //THIS PART HERE!
        else if (parsed.protocol === "ftp:") {
            let username = decodeURIComponent(parsed.username);
            let password = decodeURIComponent(parsed.password);
            let filename = decodeURIComponent(parsed.pathname);
            let ftpClient = await connectFtp({
                host: parsed.hostname,
                port: parsed.port !== "" ? parseInt(parsed.port) : undefined,
                user: username !== "" ? username : undefined,
                password: password !== "" ? password : undefined,
            });
            image = await ftpClient.get(filename);
        } else {
            return res.status(500).send("Bad image url");
        }
                if (!isPNG(image)) {
            return res.status(500).send("Bad image (not a png)");
        }

        res.type(".png").status(200).send(image);
    })

    app.listen("4101");

```
Image: the profile picture we would upload when we register as a new user. For HTTP and HTTPS protocols it's a simple GET method, not much to do there. But for ftp? 
It asks for the username, password and filename, _unchecked_, then asynchronously asks the server for the image that matches the filename that we specified. 
FTP is a text-based protocol, and since username and password fields are passed to it unchecked, we could definitely inject some protocol commands and make ftp do things the user didn't intend for us to do.

Here's something I learned in my internet computing class about the FTP protocol: FTP connections have two modes : "Active" and "Passive". In active mode, the client requests via the PORT command a communication channel to the server. The server will then establish the data connection itself to the specified location - which could be a problem, if your client has a cautious firewall that doesn't let any incoming connections through. 
In passive, the client establishes the comm channel _and_ the data connection. Because of the aforementioned firewall issue, most FTP clients and servers operate on passive mode by default. In this case, the FTP client has full control over what port it opens the comm channel and to what other place it wants the FTP server to send things to. So, we would want to use the FTP-server on active mode, so we can take control away from the client to specify to the server where to send data to. 
More info can be found here, in the RTF specifications for FTP! TODO:LINK TO RTC

With that being said, knowing the username fields are unchecked, the attack vector is straightforward: a CRLF through the username field on the FTP server! 

Well this is all great and stuff but the flag is on the rabbitmq mail server, not the FTP server. We figured out a cool way to control the ftp server but that wasn't the actual one we wanted to exploit...

But hey, we actually already figured out a part of how to do this: send a request to the email server to get us the flag. And it seems like, now that we are able to manipulate where data from the FTP server goes, we can just use the FTP server to ask for the flag for us!

So, to recap:

1: flag.txt is in the rabbitmq server. It uses a web api that will send emails using nodemailer. There's a vulnerability with nodemailer - specify an attachment path and it will send whatever file it can find with that name to whoever. 

2: An FTP server exists for this website and is used for the retrieval of user's profile pictures. It's also possible to specify the server to operate on ACTV mode over PASV, which gives us more control over where the server sends things to. We can send FTP commands through the username field, since no input sanitization exists there, to specify FTP to go on active mode, using the PORT command.

3: We can use the FTP server to send an HTTP request to the rabbitmq server, asking to email to us flag.txt, utilizing this function in ...\services\email\index.ts:

```js

    let channel = await rabbit.createChannel();
    channel.consume("email", async (msg) => {
        if (msg === null) {
            return;
        }
        channel.ack(msg);

        try {
            let data = JSON.parse(msg.content.toString());
            await transport.sendMail({
                from: "plaid2020problem@gmail.com",
                subject: "Your Account",
                ...data,
            });
        } catch (e) {
            console.error(e);
        }
    })
}
```


This challlenge requires you to hide the HTTP message to send to the rabbitmq server into your profile picture. You can hide it in the request data. 

And then, we just execute some FTP commands to split the response essentially and have the server return to us the image. When it does so, the raw HTTP POST request will get sent to the mail server! 

TODO: More info

Note: the ftp server immediately closes the data channel after sending a POST request, so the mail server wouldn't have had enough time to formulate the email and response. I worked around this by literally sending a bunch of garbage requests to force the TCP connection to stay alive for long enough.

And sure enough, I recieved the flag in my email :)

This was a great web problem! The payoff was rewarding and seeing all the moving parts all together was equal parts satisfying and interesting! 

Jam